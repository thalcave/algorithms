#include <iostream>
#include <stdlib.h>
#include <math.h>

/*
 * 
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?


if 
	n = p^a * q^b * r^c .... (with p, q, r ....prime factors) 
then 
	no_divisors(n) = (a+1)(b+1)(c+1)...

 */

/*unsigned
getNoDivisors(unsigned long csum)
{
	unsigned no_divisors = 1;
	
	for (unsigned long idx = 2; idx < csum; ++idx)
	{
		ldiv_t result = ldiv(csum, idx);
		if (!result.rem)
		{
			if (result.quot > idx)
			{
				++no_divisors;
			}
			else
			{
				if (result.quot < idx)
				{
					return no_divisors * 2;
				}
				
				//equal
				return no_divisors * 2 + 1;
			}
		}
	}
	
	return 0;
}*/

unsigned 
getNoDivisors(unsigned long trinum)
{
	unsigned count=0,i=1;

	if(trinum==1) 
		return 1;
	
	while (trinum>1 && i<=sqrt(trinum))
	{
		if (trinum%i==0)
		{
			count+=2;
		}
		i++;
	}
	
	return count;
}

bool
isPrime(unsigned long number)
{
	if (number <=1)
		return false;
	
	unsigned long sqr_root = sqrt(number) + 1;
	
	for (unsigned long i = 2; i < sqr_root; ++i)
	{
		if  (!(number % i))
		{
			return false;
		}
	}
	
	return true;
}

//get no. of divisors using the prime factors
unsigned long
noDivisorsPrimeFactor(unsigned long number)
{
	//prime factor = prime number which divides an integer exactly
	unsigned long limit = number/2;
	
	unsigned long idx = 2;
	
	ldiv_t result = {0};
	
	unsigned long no_divisors = 1;
	
	while (idx <= limit)
	{
		if (isPrime(idx))
		{
			unsigned power = 0;
			result = ldiv(number, idx);
			while (!result.rem)
			{
				++power;
				result = ldiv(result.quot, idx);
			}
			
			if (power)
			{
				no_divisors *= (power + 1);
				//std::cout <<" PFD: "<<idx << " power: "<<power<<"\n";
			}
		}
		++idx;

	}

	
	return no_divisors;
}



unsigned long
getTriangleNumber()
{
	unsigned long no_divisors = 500;
	
	unsigned long csum = 1, cnum = 1;
	
	while (csum < no_divisors)
	{
		++cnum;
		csum += cnum;
	}
	
	std::cout<<"csum: "<<csum<<"\n";
	
	while (1)
	{
		//unsigned result = noDivisorsPrimeFactor(csum);
		unsigned result = getNoDivisors(csum);
		if (result > no_divisors)
		{
			std::cout<<"no. of divisors for csum: "<<csum<<" is "<<result<<"\n";
			return csum;
		}
		
		++cnum;
		csum += cnum;
	}
}

unsigned long
getNumber()
{
	unsigned long no_divisors = 500;
	//use the formula: n(n+1)/2 to compute the number
	unsigned long cnumber = 2;
	unsigned no_div_1, no_div_2;
	while (1)
	{
		if (!(cnumber % 2))
		{
			no_div_1 = noDivisorsPrimeFactor(cnumber/2);
			no_div_2 = noDivisorsPrimeFactor(cnumber+1);
		}
		else
		{
			no_div_1 = noDivisorsPrimeFactor(cnumber);
			no_div_2 = noDivisorsPrimeFactor((cnumber+1)/2);
		}
		
		unsigned result = no_div_1 * no_div_2;
		if (result > no_divisors)
		{
			std::cout<<"no. of divisors for csum: "<<(cnumber * 0.5 * (cnumber + 1))<<" is "<<result<<"\n";
			return (cnumber * 0.5 * (cnumber + 1));
		}
		
		//std::cout<<"no. of divisors for csum: "<<(cnumber * 0.5 * (cnumber + 1))<<" is "<<result<<"\n";
		
		++cnumber;
		
	}
}


int main()
{
	std::cout<<"triangle number: "<<getTriangleNumber()<<"\n";//!fastest
	//std::cout<<"triangle number: "<<getNumber()<<"\n";
	return 0;
}